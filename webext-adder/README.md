# arcollect-webext-adder input/output format

The  `arcollect-webext-adder` is the program that handle WebExtension native host messaging. It communicate using JSON strings and add new artworks into the database.

Within the webextension, you pass this object to the `Arcollect.submit()` function, this function manage the communication with this C++ application and add entries wrapping. Read the Webxtension development section for important informations as this file document the C++ application input format.

**Warning!** This protocol is unstable and reserved for Arcollect internal workings. Though if you really want to add an artwork, using it is still safer than directly changing the even more unstable schema.

## Supported download URL scheme
**Arcollect is paranoid and requires `https://` transfer with TLS 1.2 at least**. `http://` is voluntary not supported to preserve user privacy (the webextension does the same).

Since all supported platforms and operating systems support this version of TLS, dealing with a weaker TLS is very likely someone trying a [MITM](https://en.wikipedia.org/wiki/Man-in-the-middle_attack), this requirement will be bumped up in the future.

Base64 data URL (but not the percent-encoded ones) are also supported, when the resource is not directly downloadable or require formatting performed by the webextension.

## Webextension development
You will need to generate the JSON described in the Query format section but the `Arcollect.submit()` function do some post-processing:

* The `"transaction_id"` and whole communication is managed for you, do not set ot.
* The `"dns_prefill"` is automatically generated by scanning your JSON, do not set ot.
* The `"referrer_policy"` is unset is pulled from `<meta>` pages if available.
* Download specifications allows a `"cookies": true,` field in order to auto-generate the `Cookie` header. This is a temporary workaround for DeviantArt.
* Download specifications accept many HTML elements (`<img>`, `<a>`, ...). **That is the recommended way to extract a link from HTML elements.**

## Query format
Here is an example showing all possible cases (unless I forgot something ü§îÔ∏è) of a query to add something in the database.

When adding artwork, send the plain artwork with this kind of JSON :

```json
{
	"platform": "example.net",
	"transaction_id": "123456",
	"referrer_policy": "strict-origin-when-cross-origin",
	"dns_prefill": {
		"example.com": ["ip1", "ip2..."]
	}
	"artworks": [{
		"title": "Sample art",
		"desc": "My sample warmup for the morning.",
		"source": "https://example.net/art/123456/",
		"rating": 0,
		"spdx": "CC-BY-4.0",
		"data": "<... download specification ...>",
		"thumbnail": "<... download specification ...>"
	}],
	"accounts": [{
		"id": 4213,
		"name": "@drawauthor",
		"title": "DrawAuthor make drawings",
		"url": "https://example.net/user/4213/",
		"desc": "I draw artworks.",
		"icon": "<... download specification ...>"
	}],
	"tags": [{
		"id": 2134,
		"title": "Dragon",
		"kind": "species"
	}],
	"comics": [
		"id": "abcdef",
		"title": "My comic",
		"url": "https://example.net/comic/abcdef/",
		"postdate": 1638227530,
		"pages": {
			<comic page specification...>
		}
	}],
	"art_acc_links": [{
		"artwork": "https://example.net/art/123456/",
		"account": 4213,
		"link": "account"
	}],
	"art_tag_links": [{
		"artwork": "https://example.net/art/123456/",
		"tag": 2134,
	}]
}
```
The `platform` is the platform identifier, the root URL of the platform like `twitter.com`. 

The `transaction_id` is a  string that is returned verbatim in the response to help the extension identify the tab destination.

The `referrer_policy` string to use, use the [standard format of the "Referrer-Policy"](https://developer.mozilla.org/docs/Web/HTTP/Headers/Referrer-Policy). Note that since Arcollect is https:// only, some policies are aliased internally.

The `dns_prefill` is a dictionary that map domain name to an array of string with their already resolved IP addresses. It allows to reuse application DNS cache to improve performances and privacy. Note that the webextension resolve all domain names, even those not in browser cache, in order to provide consistent behavior since the browser use it's own DNS resolver.

The `artwork` array contain objects you wants to add with some properties :

* `title` is the artwork title.
* `desc` is the artwork description.
* `source` is the artwork URL. Caution ! This is a key in the database, reformat `window.location` in a way that the same artwork always have the same URL.
* `rating` is the artwork rating. See the schema explanation of `artworks` table in file [init.sql](https://github.com/DevilishSpirits/arcollect/blob/master/sql/init.sql).
* `postdate` is the UNIX timestamp of when the artworks has been posted (optional).
* `license` is the license SPDX identifier. **Be extremely careful about it!** Do not set it if the website does not have a clever way to retrieve it or is known to be innacurate.
* `data` describe how to download the artwork file itself, most times the `https://` CDN link just works.
* `thumbnail` is the image thumbnail to show for non image type artworks. Same format as `data`.

The `account` array contain users you might wants to add with some properties :

* `id` is the user internal id on the platform. It should be an immutable numeric id if available, or `name`. This is a key in the database. For example on Twitter `1294737021714550784`, you can use text.
* `name` is the username on the platform. Often something not very pretty with a limited charset. For example on Twitter `"@DevilishSpirits"`.
* `title` is the pretty username, if different from the `name` title. For example on Twitter `"D-Spirits"`.
* `url` is the account URL.
* `icon` describe how to download the account avatar, most times the `https://` CDN link just works.
* `desc` is the account description.
* `createdate` is the UNIX timestamp of when the account has been created (optional).

The `tags` array contain tags you might wants to add with some properties :

* `id` is the tag internal id on the platform. It should be immutable. This is a key in the database. It can be a string or an integer
* `title` is the pretty tag title, if different from `id`.
* `kind` is the tag kind. See the schema explanation of `tags` table in file [init.sql](https://github.com/DevilishSpirits/arcollect/blob/master/sql/init.sql).
* `createdate` is the UNIX timestamp of when the tag has been created (optional).

The `comics` array contain comics you might wants to add with some properties :

* `id` is the comic internal id on the platform. It should be immutable. This is a key in the database. It can be a string or an integer. **It's optionnal and only useful if the platform have a concept of comics!** Else you shall skip all fields except `pages` and Arcollect will generate a comics like ordering without creating a comic database entry. An example is Twitter and FurAffinity where the comics system allow ordering.
* `title` is the comic title.
* `url` is the comic URL.
* `postdate` is the UNIX timestamp of when the comic has been posted (optional).

The `art_acc_link` array contain links with artworks and profiles :

* `artwork` is the artwork `"source"` to link.
* `account` is the account `"id"`.
* `link` describre the type of link. Here `"account"` mean that this is the account which posted the artwork. Valid values are listed in the explanation of `art_acc_links` table in file [init.sql](https://github.com/DevilishSpirits/arcollect/blob/master/sql/init.sql).

The `art_tag_link` array contain links with artworks and tags :
* `artwork` is the artwork `"source"` to link.
* `tag` is the tag `"id"`.

This JSON is fully parsed before performing a transaction on the database. Items order in the JSON is not important.

### Download specification
Simple download specification are the string URL to download from or the HTML
element to use as reference in the webextension (recommended).
This works for normal platforms, for weird ones you can pass a JSON object that
customize the Arcollect behavior. Arcollect use the collection as an HTTP cache
and might just do nothing or weird magic (picking right in the web-browser cache
for extra performance and privacy is tempting...).

In the webextension it is common that the link is located in the `href` of a
`<a>` or `src` of an `<img>` element. In such case don't extract it manually but
if the defaults belows are satisfying just shove this object directly as a
download specification or use `Arcollect.makeDownloadSpec()` with the element
and the download specification JSON (without `"data"` of course).
This way `"referrerpolicy"` will be respected and a better not trivial source
might be extracted from this element.

The defaults of download specifications are :

```json
	{
		"data": "https:// or data:<mime>;Base64,..",
		"integrity": null,
		"cache_key": "'data' or a JSON null if Base64",
		"mimetype": "Content-Type header",
		"ok_codes": [200],
		"redirection_count": 0,
		"referrer_policy": "referrer_policy in the root object"
		"headers": {
			"Referer": "The page source",
			"User-Agent": "Arcollect/<version> curl/<version>"
		}
	}
```

* `data` is the URL/Base64 you want to download
* `integrity` is the [Subresource Integrity](https://developer.mozilla.org/docs/Web/Security/Subresource_Integrity)
  fingerprint of the resource.
  The webext-adder does not support this key yet and ignore it currently.
  Tests sets have a `data.sha256` key, this one is only meant for Arollect
  testing and shall not be used outside test units.
* `cache_key` allows to override the key for matching in database. A use case is
  the DeviantArt CDN which use time limited keys, the `cache_key` strip this
  part. Passing `null` (default if `data` is a data URI) completely disable
  caching.
* `mimetype` allows to override the MIME type. It is mandatory if the server
  don't send a [`Content-Type`](https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Content-Type)
  header.
* `ok_codes` is an array of code we consider a success. FurAffinity does return
  a 404 with a valid GIF if an account use the default avatar.
* `redirection_count` is the number of redirections allowed. Negative values are
  undefined and currently may either generates an error or behave as zero.
* `referrer_policy` to use for this request.
* `headers` is a dictionary of custom headers to set, you can unset default
  Arcollect and curl headers with a `null` value (a JSON `null`, not a `"null"`
  aka a string with "null" inside).

### Comics pages specification
This field is a list of pages in your comic. You should include data for all
artworks you know that are in the comic in addition of them that you save.
Arcollect save informations about the artworks the user doesn't save and will
try to resolve missing links.

Let's take an example of a comic where you have a page, the next, the previous,
the first and the last one of the comic.

```json
	"pages": {
		"https://example.com/cover#front": {"relative_to": "front_cover"},
		"https://example.com/first_page" : {"relative_to": "main", "page":  1, "sub": 0},
		"https://example.com/prev_page"  : {"relative_to": "main", "page": 12, "sub": 0},
		"https://example.com/the_page"   : {"relative_to": "main", "page": 13, "sub": 0},
		"https://example.com/next_page"  : {"relative_to": "main", "page": 14, "sub": 0},
		"https://example.com/last_page"  : {"relative_to": "main", "page": -1, "sub": 0},
	}]
```

Each items of the array is a single comic, this is an object using artwork
sources as keys and another object at source.

The `relative_to` string can be either a section name (`part`, `prolog`, ...)
when you know the exact position, or an artwork source when you only have
relative informations, in this case you must be relative to an artwork that you
are saving.

The `page`/`sub` is the page number/subartwork offset (0 by default), you can
use negative number for *the last nth page* in sections.

This offset is relative to `relative_to`, `"page": 1` for artwork source mean
that this artwork is the next page to `relative_to`, for a section this is the
first page in the section.

In the example I put `"sub": 0`, this is entirely optional, I miss both `page`
and `sub `in the `front_cover` because I want both to be zero.

Note that Arcollect might not store your comic as is within the database.

## Result format

The program add artworks into the database and return an object when this is done :

```json
{
	"success": true,
	"transaction_id": "123456"
}
```

Or this failed :

```json
{
	"success": false,
	"reason": "A message describing what's wrong.",
	"transaction_id": "123456"
}
```

The `success` is self-explanatory.

The `reason` is a string describing what goes wrong that you should display to the user.

The `transaction_id` is the same JSON string that was sent in the corresponding request.
